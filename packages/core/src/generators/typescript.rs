// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! TypeScript code generator
//!
//! Generates TypeScript interfaces and Borsh schemas from IR for client-side integration.

use crate::ir::{TypeDefinition, TypeInfo};
use std::collections::HashSet;

/// Generate TypeScript code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let imports = collect_imports(type_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("{};\n", import));
        }
        output.push_str("\n");
    }

    // Generate interface
    output.push_str(&generate_interface(type_def));
    output.push_str("\n");

    // Generate Borsh schema if Solana type
    if type_def.metadata.solana {
        output.push_str(&generate_borsh_schema(type_def));
    }

    output
}

/// Generate TypeScript code for multiple type definitions
pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect all imports needed
    let mut all_imports = HashSet::new();
    for type_def in type_defs {
        let imports = collect_imports(type_def);
        all_imports.extend(imports);
    }

    // Write imports
    if !all_imports.is_empty() {
        let mut sorted_imports: Vec<_> = all_imports.into_iter().collect();
        sorted_imports.sort();
        for import in sorted_imports {
            output.push_str(&format!("{};\n", import));
        }
        output.push_str("\n");
    }

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push_str("\n");
        }
        output.push_str(&generate_interface(type_def));

        // Add Borsh schema for Solana types
        if type_def.metadata.solana {
            output.push_str("\n");
            output.push_str(&generate_borsh_schema(type_def));
            if i < type_defs.len() - 1 {
                output.push_str("\n");
            }
        }
    }

    output
}

/// Generate TypeScript interface
fn generate_interface(type_def: &TypeDefinition) -> String {
    let mut output = String::new();

    // Generate interface
    output.push_str(&format!("export interface {} {{\n", type_def.name));

    // Generate fields
    for field in &type_def.fields {
        let ts_type = map_type_to_typescript(&field.type_info);
        let optional_marker = if field.optional { "?" } else { "" };
        output.push_str(&format!("  {}{}: {};\n", field.name, optional_marker, ts_type));
    }

    output.push_str("}\n");

    output
}

/// Generate Borsh schema for serialization
fn generate_borsh_schema(type_def: &TypeDefinition) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "export const {}Schema = borsh.struct([\n",
        type_def.name
    ));

    // Generate Borsh field definitions
    for field in &type_def.fields {
        let borsh_type = map_type_to_borsh(&field.type_info);
        output.push_str(&format!("  {}('{}'),\n", borsh_type, field.name));
    }

    output.push_str("]);\n");

    output
}

/// Collect required imports based on type definition
fn collect_imports(type_def: &TypeDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check field types for imports
    let mut needs_publickey = false;
    let needs_borsh = type_def.metadata.solana;

    for field in &type_def.fields {
        collect_imports_from_type(&field.type_info, &mut needs_publickey);
    }

    if needs_publickey {
        imports.insert("import { PublicKey } from '@solana/web3.js'".to_string());
    }

    if needs_borsh {
        imports.insert("import * as borsh from '@coral-xyz/borsh'".to_string());
    }

    imports
}

/// Recursively check if type needs specific imports
fn collect_imports_from_type(type_info: &TypeInfo, needs_publickey: &mut bool) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            if type_name == "Pubkey" || type_name == "PublicKey" {
                *needs_publickey = true;
            }
        }
        TypeInfo::Array(inner) => {
            collect_imports_from_type(inner, needs_publickey);
        }
        TypeInfo::Option(inner) => {
            collect_imports_from_type(inner, needs_publickey);
        }
        TypeInfo::UserDefined(_) => {
            // User-defined types are in the same module
        }
    }
}

/// Map IR type to TypeScript type
fn map_type_to_typescript(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            match type_name.as_str() {
                // Integer types â†’ number (except u128/i128)
                "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" => {
                    "number".to_string()
                }
                "u128" | "i128" => "bigint".to_string(),

                // Floating point
                "f32" | "f64" => "number".to_string(),

                // Boolean
                "bool" => "boolean".to_string(),

                // String
                "String" => "string".to_string(),

                // Solana types
                "Pubkey" | "PublicKey" => "PublicKey".to_string(),
                "Signature" => "string".to_string(),
                "Keypair" => "Keypair".to_string(),

                // Unknown - pass through
                _ => type_name.clone(),
            }
        }
        TypeInfo::Array(inner) => {
            let inner_type = map_type_to_typescript(inner);
            format!("{}[]", inner_type)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_typescript(inner);
            format!("{} | undefined", inner_type)
        }
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

/// Map IR type to Borsh type
fn map_type_to_borsh(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => match type_name.as_str() {
            "u8" => "borsh.u8".to_string(),
            "u16" => "borsh.u16".to_string(),
            "u32" => "borsh.u32".to_string(),
            "u64" => "borsh.u64".to_string(),
            "u128" => "borsh.u128".to_string(),
            "i8" => "borsh.i8".to_string(),
            "i16" => "borsh.i16".to_string(),
            "i32" => "borsh.i32".to_string(),
            "i64" => "borsh.i64".to_string(),
            "i128" => "borsh.i128".to_string(),
            "f32" => "borsh.f32".to_string(),
            "f64" => "borsh.f64".to_string(),
            "bool" => "borsh.bool".to_string(),
            "String" => "borsh.string".to_string(),
            "Pubkey" | "PublicKey" => "borsh.publicKey".to_string(),
            _ => format!("borsh.{}", type_name.to_lowercase()),
        },
        TypeInfo::Array(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("borsh.vec({})", inner_borsh)
        }
        TypeInfo::Option(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("borsh.option({})", inner_borsh)
        }
        TypeInfo::UserDefined(type_name) => {
            // User-defined types need their schema
            format!("{}Schema", type_name)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{FieldDefinition, Metadata, TypeDefinition, TypeInfo};

    #[test]
    fn generates_simple_interface() {
        let type_def = TypeDefinition {
            name: "User".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("export interface User"));
        assert!(code.contains("id: number"));
        assert!(code.contains("name: string"));
    }

    #[test]
    fn generates_solana_interface_with_borsh() {
        let type_def = TypeDefinition {
            name: "UserAccount".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("PublicKey".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
            },
        };

        let code = generate(&type_def);
        assert!(code.contains("import { PublicKey } from '@solana/web3.js'"));
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export interface UserAccount"));
        assert!(code.contains("wallet: PublicKey"));
        assert!(code.contains("balance: number"));
        assert!(code.contains("export const UserAccountSchema = borsh.struct"));
        assert!(code.contains("borsh.publicKey('wallet')"));
        assert!(code.contains("borsh.u64('balance')"));
    }

    #[test]
    fn generates_optional_fields() {
        let type_def = TypeDefinition {
            name: "Profile".to_string(),
            fields: vec![FieldDefinition {
                name: "email".to_string(),
                type_info: TypeInfo::Option(Box::new(TypeInfo::Primitive("String".to_string()))),
                optional: true,
            }],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("email?: string | undefined"));
    }

    #[test]
    fn generates_array_fields() {
        let type_def = TypeDefinition {
            name: "Team".to_string(),
            fields: vec![FieldDefinition {
                name: "members".to_string(),
                type_info: TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string()))),
                optional: false,
            }],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
            },
        };

        let code = generate(&type_def);
        assert!(code.contains("members: number[]"));
        assert!(code.contains("borsh.vec(borsh.u64)('members')"));
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition {
                name: "User".to_string(),
                fields: vec![],
                metadata: Metadata::default(),
            },
            TypeDefinition {
                name: "Post".to_string(),
                fields: vec![],
                metadata: Metadata::default(),
            },
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("export interface User"));
        assert!(code.contains("export interface Post"));
    }

    #[test]
    fn maps_bigint_types() {
        let type_def = TypeDefinition {
            name: "BigNumbers".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "big_unsigned".to_string(),
                    type_info: TypeInfo::Primitive("u128".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "big_signed".to_string(),
                    type_info: TypeInfo::Primitive("i128".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("big_unsigned: bigint"));
        assert!(code.contains("big_signed: bigint"));
    }
}
