// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Integration tests for Rust code generator
//!
//! Tests the complete pipeline: .lumos → AST → IR → Rust code

use lumos_core::generators::rust::{generate, generate_module};
use lumos_core::parser::parse_lumos_file;
use lumos_core::transform::transform_to_ir;
use std::fs;
use std::path::PathBuf;

#[test]
fn test_generate_gaming_schema() {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path.push("examples/gaming/schema.lumos");

    let content = fs::read_to_string(&path).expect("Failed to read gaming schema");

    // Parse and transform
    let ast = parse_lumos_file(&content).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    // Generate Rust code for all types
    let rust_code = generate_module(&ir);

    // Verify code contains expected elements
    assert!(rust_code.contains("pub struct PlayerAccount"));
    assert!(rust_code.contains("pub struct GameItem"));
    assert!(rust_code.contains("pub struct Leaderboard"));
    assert!(rust_code.contains("pub struct MatchResult"));

    // Verify Anchor imports (since module has #[account] structs)
    assert!(rust_code.contains("use anchor_lang::prelude::*"));

    // Verify Solana imports
    assert!(rust_code.contains("use solana_program::pubkey::Pubkey"));

    // Verify #[account] structs have NO derives (Anchor provides them)
    // MatchResult (non-account) should use AnchorSerialize/AnchorDeserialize
    assert!(rust_code.contains("AnchorSerialize, AnchorDeserialize"));

    // Verify account attribute
    assert!(rust_code.contains("#[account]"));

    // Verify fields from PlayerAccount
    assert!(rust_code.contains("pub wallet: Pubkey"));
    assert!(rust_code.contains("pub username: String"));
    assert!(rust_code.contains("pub level: u16"));
    assert!(rust_code.contains("pub equipped_items: Vec<Pubkey>"));

    // Verify optional field from MatchResult
    assert!(rust_code.contains("pub opponent: Option<Pubkey>"));

    println!("Generated Rust code:\n{}", rust_code);
}

#[test]
fn test_generate_nft_marketplace_schema() {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path.push("examples/nft-marketplace/schema.lumos");

    let content = fs::read_to_string(&path).expect("Failed to read NFT marketplace schema");

    let ast = parse_lumos_file(&content).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let rust_code = generate_module(&ir);

    // Verify struct definitions
    assert!(rust_code.contains("pub struct Marketplace"));
    assert!(rust_code.contains("pub struct NftListing"));
    assert!(rust_code.contains("pub struct NftMetadata"));
    assert!(rust_code.contains("pub struct PurchaseReceipt"));

    // Verify optional field
    assert!(rust_code.contains("pub expires_at: Option<i64>"));

    // Verify array field
    assert!(rust_code.contains("pub creators: Vec<Pubkey>"));

    // Verify Signature type (mapped to String for base58 encoding)
    assert!(rust_code.contains("pub transaction_signature: String"));

    println!("Generated Rust code:\n{}", rust_code);
}

#[test]
fn test_generate_single_struct() {
    let lumos_code = r#"
        #[solana]
        #[account]
        struct SimpleAccount {
            owner: PublicKey,
            balance: u64,
        }
    "#;

    let ast = parse_lumos_file(lumos_code).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let rust_code = generate(&ir[0]);

    // Verify complete output
    assert!(rust_code.contains("// Auto-generated by LUMOS"));
    assert!(rust_code.contains("// DO NOT EDIT"));
    assert!(rust_code.contains("use anchor_lang::prelude::*"));
    assert!(rust_code.contains("use solana_program::pubkey::Pubkey"));
    // #[account] structs should have NO derives (Anchor provides them)
    assert!(!rust_code.contains("#[derive"));
    assert!(rust_code.contains("#[account]"));
    assert!(rust_code.contains("pub struct SimpleAccount {"));
    assert!(rust_code.contains("pub owner: Pubkey,"));
    assert!(rust_code.contains("pub balance: u64,"));

    println!("Generated Rust code:\n{}", rust_code);
}

#[test]
fn test_generate_defi_staking_schema() {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path.push("examples/defi-staking/schema.lumos");

    let content = fs::read_to_string(&path).expect("Failed to read DeFi staking schema");

    let ast = parse_lumos_file(&content).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let rust_code = generate_module(&ir);

    // Should generate valid Rust code with Anchor imports
    assert!(rust_code.contains("pub struct"));
    assert!(rust_code.contains("use anchor_lang::prelude::*"));
    assert!(rust_code.contains("#[account]"));
    // Non-account structs should use AnchorSerialize
    assert!(rust_code.contains("AnchorSerialize"));

    println!("Generated Rust code for DeFi Staking:\n{}", rust_code);
}

#[test]
fn test_generate_dao_governance_schema() {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path.push("examples/dao-governance/schema.lumos");

    let content = fs::read_to_string(&path).expect("Failed to read DAO governance schema");

    let ast = parse_lumos_file(&content).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let rust_code = generate_module(&ir);

    // Should generate valid Rust code with Anchor imports
    assert!(rust_code.contains("pub struct"));
    assert!(rust_code.contains("use anchor_lang::prelude::*"));
    assert!(rust_code.contains("#[account]"));
    // All structs have #[account], so no derives needed

    println!("Generated Rust code for DAO Governance:\n{}", rust_code);
}
