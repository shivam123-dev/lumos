// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! TypeScript Code Generator
//!
//! Generates TypeScript interfaces and Borsh schemas from IR for client-side Solana
//! integration with guaranteed serialization compatibility.
//!
//! ## Overview
//!
//! This generator produces type-safe TypeScript code for Solana dApp frontends with:
//!
//! - **TypeScript Interfaces** - Type-safe data structures for IDE support
//! - **Borsh Schemas** - Serialization/deserialization compatible with Rust on-chain code
//! - **Discriminated Unions** - Type-safe enums with `kind` field for narrowing
//! - **Solana Web3.js Integration** - Automatic imports for `PublicKey`, `Keypair`
//!
//! ## Discriminated Union Pattern (Enums)
//!
//! Rust enums are mapped to TypeScript discriminated unions with a `kind` field:
//!
//! ```rust,ignore
//! // LUMOS schema
//! enum GameState {
//!     Active,
//!     Paused,
//!     Finished,
//! }
//! ```
//!
//! ```typescript
//! // Generated TypeScript
//! export type GameState =
//!   | { kind: 'Active' }
//!   | { kind: 'Paused' }
//!   | { kind: 'Finished' };
//! ```
//!
//! ## Type Mapping
//!
//! IR types are mapped to TypeScript types:
//!
//! | IR Type | TypeScript | Borsh Schema | Notes |
//! |---------|------------|--------------|-------|
//! | `u8`, `u16`, `u32`, `u64` | `number` | `borsh.u64`, etc. | Safe for values < 2^53 |
//! | `u128`, `i128` | `bigint` | `borsh.u128`, `borsh.i128` | Native BigInt support |
//! | `String` | `string` | `borsh.string` | UTF-8 strings |
//! | `bool` | `boolean` | `borsh.bool` | - |
//! | `PublicKey` | `PublicKey` | `borsh.publicKey` | From `@solana/web3.js` |
//! | `[T]` | `T[]` | `borsh.vec(...)` | Dynamic arrays |
//! | `Option<T>` | `T \| undefined` | `borsh.option(...)` | Optional fields |
//!
//! ## Example
//!
//! ```rust
//! use lumos_core::{parser, transform, generators::typescript};
//!
//! let source = r#"
//!     #[solana]
//!     #[account]
//!     struct UserAccount {
//!         wallet: PublicKey,
//!         balance: u64,
//!         items: [PublicKey],
//!     }
//! "#;
//!
//! let ast = parser::parse_lumos_file(source)?;
//! let ir = transform::transform_to_ir(ast)?;
//! let ts_code = typescript::generate_module(&ir);
//!
//! // Generated TypeScript includes interface + Borsh schema
//! assert!(ts_code.contains("export interface UserAccount"));
//! assert!(ts_code.contains("export const UserAccountSchema = borsh.struct"));
//! assert!(ts_code.contains("borsh.publicKey('wallet')"));
//! assert!(ts_code.contains("borsh.u64('balance')"));
//! assert!(ts_code.contains("borsh.vec(borsh.publicKey)('items')"));
//! # Ok::<(), Box<dyn std::error::Error>>(())
//! ```

use crate::ir::{
    EnumDefinition, EnumVariantDefinition, StructDefinition, TypeDefinition, TypeInfo,
};
use std::collections::HashSet;

/// Generate TypeScript code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    match type_def {
        TypeDefinition::Struct(struct_def) => generate_struct(struct_def),
        TypeDefinition::Enum(enum_def) => generate_enum(enum_def),
    }
}

/// Generate TypeScript code from a struct definition
fn generate_struct(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let imports = collect_struct_imports(struct_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("{};\n", import));
        }
        output.push('\n');
    }

    // Generate interface
    output.push_str(&generate_struct_interface(struct_def));
    output.push('\n');

    // Generate Borsh schema if Solana type
    if struct_def.metadata.solana {
        output.push_str(&generate_struct_borsh_schema(struct_def));
    }

    output
}

/// Generate TypeScript code from an enum definition
fn generate_enum(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect required imports
    let imports = collect_enum_imports(enum_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("{};\n", import));
        }
        output.push('\n');
    }

    // Generate discriminated union type
    output.push_str(&generate_enum_type(enum_def));
    output.push('\n');

    // Generate Borsh schema if Solana type
    if enum_def.metadata.solana {
        output.push_str(&generate_enum_borsh_schema(enum_def));
    }

    output
}

/// Generate TypeScript code for a complete module with multiple type definitions.
///
/// This is the primary function for generating TypeScript code from IR. It handles
/// import management, interface generation, and Borsh schema creation for all types.
///
/// # Arguments
///
/// * `type_defs` - Slice of IR type definitions (structs and enums)
///
/// # Returns
///
/// Complete TypeScript source code as a `String`, ready to write to a `.ts` file.
/// Includes:
/// - Auto-generated file header
/// - Optimized imports (`@solana/web3.js`, `@coral-xyz/borsh`)
/// - TypeScript interfaces for structs
/// - Discriminated union types for enums
/// - Borsh schemas for Solana types (serialization/deserialization)
///
/// # Import Management
///
/// The function analyzes all types to determine required imports:
///
/// - `import { PublicKey } from '@solana/web3.js'` - When `PublicKey` or `Pubkey` types detected
/// - `import * as borsh from '@coral-xyz/borsh'` - For Solana types (with `#[solana]` attribute)
///
/// # Enum Generation Strategy
///
/// Enums are converted to TypeScript discriminated unions with a `kind` field for type narrowing:
///
/// - **Unit variants**: `{ kind: 'VariantName' }`
/// - **Tuple variants**: `{ kind: 'VariantName'; field0: Type; field1: Type }`
/// - **Struct variants**: `{ kind: 'VariantName'; fieldName: Type }`
///
/// This enables TypeScript's type narrowing for safe pattern matching.
///
/// # Example
///
/// ```rust
/// use lumos_core::{parser, transform, generators::typescript};
///
/// let source = r#"
///     #[solana]
///     #[account]
///     struct UserAccount {
///         wallet: PublicKey,
///         balance: u64,
///     }
///
///     #[solana]
///     enum GameState {
///         Active,
///         Paused,
///         Finished,
///     }
/// "#;
///
/// let ast = parser::parse_lumos_file(source)?;
/// let ir = transform::transform_to_ir(ast)?;
/// let ts_code = typescript::generate_module(&ir);
///
/// // Includes necessary imports
/// assert!(ts_code.contains("import { PublicKey } from '@solana/web3.js'"));
/// assert!(ts_code.contains("import * as borsh from '@coral-xyz/borsh'"));
///
/// // Struct interface + Borsh schema
/// assert!(ts_code.contains("export interface UserAccount"));
/// assert!(ts_code.contains("export const UserAccountSchema = borsh.struct"));
///
/// // Enum discriminated union + Borsh schema
/// assert!(ts_code.contains("export type GameState ="));
/// assert!(ts_code.contains("{ kind: 'Active' }"));
/// assert!(ts_code.contains("export const GameStateSchema = borsh.rustEnum"));
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
///
/// # Generated Code Structure
///
/// ```typescript
/// // Auto-generated by LUMOS
/// // DO NOT EDIT - Changes will be overwritten
///
/// import { PublicKey } from '@solana/web3.js';
/// import * as borsh from '@coral-xyz/borsh';
///
/// export interface UserAccount {
///   wallet: PublicKey;
///   balance: number;
/// }
///
/// export const UserAccountSchema = borsh.struct([
///   borsh.publicKey('wallet'),
///   borsh.u64('balance'),
/// ]);
///
/// export type GameState =
///   | { kind: 'Active' }
///   | { kind: 'Paused' }
///   | { kind: 'Finished' };
///
/// export const GameStateSchema = borsh.rustEnum([
///   borsh.unit('Active'),
///   borsh.unit('Paused'),
///   borsh.unit('Finished'),
/// ]);
/// ```
// Estimate output size for string capacity pre-allocation
//
// Reduces reallocations for large schemas by estimating the final size.
// Conservative estimate to avoid excessive over-allocation.
//
// # Estimation Formula
//
// - Base overhead: ~250 bytes (header, imports)
// - Per struct: ~180 bytes + (fields × 70 bytes) [includes Borsh schema]
// - Per enum: ~150 bytes + (variants × 60 bytes) [includes Borsh schema]
fn estimate_output_size(type_defs: &[TypeDefinition]) -> usize {
    const BASE_OVERHEAD: usize = 250;
    const STRUCT_BASE: usize = 180;
    const FIELD_SIZE: usize = 70;
    const ENUM_BASE: usize = 150;
    const VARIANT_SIZE: usize = 60;

    let mut total = BASE_OVERHEAD;

    for type_def in type_defs {
        total += match type_def {
            TypeDefinition::Struct(s) => STRUCT_BASE + (s.fields.len() * FIELD_SIZE),
            TypeDefinition::Enum(e) => ENUM_BASE + (e.variants.len() * VARIANT_SIZE),
        };
    }

    total
}

pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    // Estimate output size to reduce allocations for large schemas
    let estimated_capacity = estimate_output_size(type_defs);
    let mut output = String::with_capacity(estimated_capacity);

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Collect all imports needed
    let mut all_imports = HashSet::new();
    for type_def in type_defs {
        match type_def {
            TypeDefinition::Struct(s) => {
                let imports = collect_struct_imports(s);
                all_imports.extend(imports);
            }
            TypeDefinition::Enum(e) => {
                let imports = collect_enum_imports(e);
                all_imports.extend(imports);
            }
        }
    }

    // Write imports
    if !all_imports.is_empty() {
        let mut sorted_imports: Vec<_> = all_imports.into_iter().collect();
        sorted_imports.sort();
        for import in sorted_imports {
            output.push_str(&format!("{};\n", import));
        }
        output.push('\n');
    }

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push('\n');
        }

        match type_def {
            TypeDefinition::Struct(s) => {
                output.push_str(&generate_struct_interface(s));

                // Add Borsh schema for Solana types
                if s.metadata.solana {
                    output.push('\n');
                    output.push_str(&generate_struct_borsh_schema(s));
                    if i < type_defs.len() - 1 {
                        output.push('\n');
                    }
                }
            }
            TypeDefinition::Enum(e) => {
                output.push_str(&generate_enum_type(e));

                // Add Borsh schema for Solana types
                if e.metadata.solana {
                    output.push('\n');
                    output.push_str(&generate_enum_borsh_schema(e));
                    if i < type_defs.len() - 1 {
                        output.push('\n');
                    }
                }
            }
        }
    }

    output
}

/// Check if a TypeInfo contains u64 or i64 types (which map to TypeScript 'number' with precision limits)
fn contains_u64_or_i64(type_info: &TypeInfo) -> bool {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            matches!(type_name.as_str(), "u64" | "i64")
        }
        TypeInfo::Array(inner) | TypeInfo::Option(inner) => contains_u64_or_i64(inner),
        TypeInfo::UserDefined(_) => false, // User-defined types are checked separately
    }
}

/// Generate TypeScript interface for struct
fn generate_struct_interface(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    // Generate interface
    output.push_str(&format!("export interface {} {{\n", struct_def.name));

    // Generate fields
    for field in &struct_def.fields {
        let ts_type = map_type_to_typescript(&field.type_info);
        let optional_marker = if field.optional { "?" } else { "" };

        // Add JSDoc warning for u64/i64 types (precision limitation)
        if contains_u64_or_i64(&field.type_info) {
            output.push_str("  /**\n");
            output.push_str("   * WARNING: TypeScript 'number' has precision limit of 2^53-1 (9,007,199,254,740,991).\n");
            output.push_str(
                "   * For Solana lamports or large values, ensure they stay within safe range.\n",
            );
            output.push_str(
                "   * Values exceeding this limit will lose precision during serialization.\n",
            );
            output.push_str("   */\n");
        }

        output.push_str(&format!(
            "  {}{}: {};\n",
            field.name, optional_marker, ts_type
        ));
    }

    output.push_str("}\n");

    output
}

/// Generate Borsh schema for struct serialization
fn generate_struct_borsh_schema(struct_def: &StructDefinition) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "export const {}Schema = borsh.struct([\n",
        struct_def.name
    ));

    // Generate Borsh field definitions
    for field in &struct_def.fields {
        let borsh_type = map_type_to_borsh(&field.type_info);
        output.push_str(&format!("  {}('{}'),\n", borsh_type, field.name));
    }

    output.push_str("]);\n");

    output
}

/// Generate TypeScript discriminated union type for enum
fn generate_enum_type(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    // Check if any variant contains u64/i64 types
    let has_u64_i64 = enum_def.variants.iter().any(|variant| match variant {
        EnumVariantDefinition::Unit { .. } => false,
        EnumVariantDefinition::Tuple { types, .. } => types.iter().any(contains_u64_or_i64),
        EnumVariantDefinition::Struct { fields, .. } => {
            fields.iter().any(|f| contains_u64_or_i64(&f.type_info))
        }
    });

    // Add JSDoc warning if enum contains u64/i64
    if has_u64_i64 {
        output.push_str("/**\n");
        output.push_str(" * WARNING: Some variants contain TypeScript 'number' types with precision limit of 2^53-1.\n");
        output.push_str(
            " * Large values (e.g., Solana lamports) may lose precision during serialization.\n",
        );
        output.push_str(" */\n");
    }

    // Generate discriminated union type
    output.push_str(&format!("export type {} =\n", enum_def.name));

    for variant in &enum_def.variants {
        let prefix = "  | ";

        match variant {
            EnumVariantDefinition::Unit { name } => {
                output.push_str(&format!("{}{{ kind: '{}' }}\n", prefix, name));
            }
            EnumVariantDefinition::Tuple { name, types } => {
                output.push_str(&format!("{}{{ kind: '{}'", prefix, name));
                for (idx, type_info) in types.iter().enumerate() {
                    let ts_type = map_type_to_typescript(type_info);
                    output.push_str(&format!("; field{}: {}", idx, ts_type));
                }
                output.push_str(" }\n");
            }
            EnumVariantDefinition::Struct { name, fields } => {
                output.push_str(&format!("{}{{ kind: '{}'", prefix, name));
                for field in fields {
                    let ts_type = map_type_to_typescript(&field.type_info);
                    output.push_str(&format!("; {}: {}", field.name, ts_type));
                }
                output.push_str(" }\n");
            }
        }
    }

    output.push_str(";\n");

    output
}

/// Generate Borsh schema for enum serialization
fn generate_enum_borsh_schema(enum_def: &EnumDefinition) -> String {
    let mut output = String::new();

    output.push_str(&format!(
        "export const {}Schema = borsh.rustEnum([\n",
        enum_def.name
    ));

    // Generate Borsh variant definitions
    for variant in &enum_def.variants {
        match variant {
            EnumVariantDefinition::Unit { name } => {
                output.push_str(&format!("  borsh.unit('{}'),\n", name));
            }
            EnumVariantDefinition::Tuple { name, types } => {
                output.push_str("  borsh.tuple([\n");
                for type_info in types {
                    let borsh_type = map_type_to_borsh(type_info);
                    output.push_str(&format!("    {},\n", borsh_type));
                }
                output.push_str(&format!("  ], '{}'),\n", name));
            }
            EnumVariantDefinition::Struct { name, fields } => {
                output.push_str("  borsh.struct([\n");
                for field in fields {
                    let borsh_type = map_type_to_borsh(&field.type_info);
                    output.push_str(&format!("    {}('{}'),\n", borsh_type, field.name));
                }
                output.push_str(&format!("  ], '{}'),\n", name));
            }
        }
    }

    output.push_str("]);\n");

    output
}

/// Collect required imports based on enum definition
fn collect_enum_imports(enum_def: &EnumDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check variant types for imports
    let mut needs_publickey = false;
    let needs_borsh = enum_def.metadata.solana;

    for variant in &enum_def.variants {
        match variant {
            EnumVariantDefinition::Unit { .. } => {}
            EnumVariantDefinition::Tuple { types, .. } => {
                for type_info in types {
                    collect_imports_from_type(type_info, &mut needs_publickey);
                }
            }
            EnumVariantDefinition::Struct { fields, .. } => {
                for field in fields {
                    collect_imports_from_type(&field.type_info, &mut needs_publickey);
                }
            }
        }
    }

    if needs_publickey {
        imports.insert("import { PublicKey } from '@solana/web3.js'".to_string());
    }

    if needs_borsh {
        imports.insert("import * as borsh from '@coral-xyz/borsh'".to_string());
    }

    imports
}

/// Collect required imports based on struct definition
fn collect_struct_imports(struct_def: &StructDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check field types for imports
    let mut needs_publickey = false;
    let needs_borsh = struct_def.metadata.solana;

    for field in &struct_def.fields {
        collect_imports_from_type(&field.type_info, &mut needs_publickey);
    }

    if needs_publickey {
        imports.insert("import { PublicKey } from '@solana/web3.js'".to_string());
    }

    if needs_borsh {
        imports.insert("import * as borsh from '@coral-xyz/borsh'".to_string());
    }

    imports
}

/// Recursively check if type needs specific imports
fn collect_imports_from_type(type_info: &TypeInfo, needs_publickey: &mut bool) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            if type_name == "Pubkey" || type_name == "PublicKey" {
                *needs_publickey = true;
            }
        }
        TypeInfo::Array(inner) => {
            collect_imports_from_type(inner, needs_publickey);
        }
        TypeInfo::Option(inner) => {
            collect_imports_from_type(inner, needs_publickey);
        }
        TypeInfo::UserDefined(_) => {
            // User-defined types are in the same module
        }
    }
}

/// Map IR type to TypeScript type
fn map_type_to_typescript(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            match type_name.as_str() {
                // Integer types → number (except u128/i128)
                "u8" | "u16" | "u32" | "u64" | "i8" | "i16" | "i32" | "i64" => "number".to_string(),
                "u128" | "i128" => "bigint".to_string(),

                // Floating point
                "f32" | "f64" => "number".to_string(),

                // Boolean
                "bool" => "boolean".to_string(),

                // String
                "String" => "string".to_string(),

                // Solana types
                "Pubkey" | "PublicKey" => "PublicKey".to_string(),
                "Signature" => "string".to_string(),
                "Keypair" => "Keypair".to_string(),

                // Unknown - pass through
                _ => type_name.clone(),
            }
        }
        TypeInfo::Array(inner) => {
            let inner_type = map_type_to_typescript(inner);
            format!("{}[]", inner_type)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_typescript(inner);
            format!("{} | undefined", inner_type)
        }
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

/// Map IR type to Borsh type
fn map_type_to_borsh(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => match type_name.as_str() {
            "u8" => "borsh.u8".to_string(),
            "u16" => "borsh.u16".to_string(),
            "u32" => "borsh.u32".to_string(),
            "u64" => "borsh.u64".to_string(),
            "u128" => "borsh.u128".to_string(),
            "i8" => "borsh.i8".to_string(),
            "i16" => "borsh.i16".to_string(),
            "i32" => "borsh.i32".to_string(),
            "i64" => "borsh.i64".to_string(),
            "i128" => "borsh.i128".to_string(),
            "f32" => "borsh.f32".to_string(),
            "f64" => "borsh.f64".to_string(),
            "bool" => "borsh.bool".to_string(),
            "String" => "borsh.string".to_string(),
            "Pubkey" | "PublicKey" => "borsh.publicKey".to_string(),
            _ => format!("borsh.{}", type_name.to_lowercase()),
        },
        TypeInfo::Array(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("borsh.vec({})", inner_borsh)
        }
        TypeInfo::Option(inner) => {
            let inner_borsh = map_type_to_borsh(inner);
            format!("borsh.option({})", inner_borsh)
        }
        TypeInfo::UserDefined(type_name) => {
            // User-defined types need their schema
            format!("{}Schema", type_name)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{
        EnumDefinition, EnumVariantDefinition, FieldDefinition, Metadata, StructDefinition,
        TypeDefinition, TypeInfo,
    };

    #[test]
    fn generates_simple_interface() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "User".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata::default(),
        });

        let code = generate(&type_def);
        assert!(code.contains("export interface User"));
        assert!(code.contains("id: number"));
        assert!(code.contains("name: string"));
    }

    #[test]
    fn generates_solana_interface_with_borsh() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "UserAccount".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("PublicKey".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("import { PublicKey } from '@solana/web3.js'"));
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export interface UserAccount"));
        assert!(code.contains("wallet: PublicKey"));
        assert!(code.contains("balance: number"));
        assert!(code.contains("export const UserAccountSchema = borsh.struct"));
        assert!(code.contains("borsh.publicKey('wallet')"));
        assert!(code.contains("borsh.u64('balance')"));
    }

    #[test]
    fn generates_optional_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Profile".to_string(),
            fields: vec![FieldDefinition {
                name: "email".to_string(),
                type_info: TypeInfo::Option(Box::new(TypeInfo::Primitive("String".to_string()))),
                optional: true,
            }],
            metadata: Metadata::default(),
        });

        let code = generate(&type_def);
        assert!(code.contains("email?: string | undefined"));
    }

    #[test]
    fn generates_array_fields() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "Team".to_string(),
            fields: vec![FieldDefinition {
                name: "members".to_string(),
                type_info: TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string()))),
                optional: false,
            }],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("members: number[]"));
        assert!(code.contains("borsh.vec(borsh.u64)('members')"));
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition::Struct(StructDefinition {
                name: "User".to_string(),
                fields: vec![],
                metadata: Metadata::default(),
            }),
            TypeDefinition::Struct(StructDefinition {
                name: "Post".to_string(),
                fields: vec![],
                metadata: Metadata::default(),
            }),
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("export interface User"));
        assert!(code.contains("export interface Post"));
    }

    #[test]
    fn maps_bigint_types() {
        let type_def = TypeDefinition::Struct(StructDefinition {
            name: "BigNumbers".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "big_unsigned".to_string(),
                    type_info: TypeInfo::Primitive("u128".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "big_signed".to_string(),
                    type_info: TypeInfo::Primitive("i128".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata::default(),
        });

        let code = generate(&type_def);
        assert!(code.contains("big_unsigned: bigint"));
        assert!(code.contains("big_signed: bigint"));
    }

    #[test]
    fn generates_unit_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameState".to_string(),
            variants: vec![
                EnumVariantDefinition::Unit {
                    name: "Active".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Paused".to_string(),
                },
                EnumVariantDefinition::Unit {
                    name: "Finished".to_string(),
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export type GameState ="));
        assert!(code.contains("{ kind: 'Active' }"));
        assert!(code.contains("{ kind: 'Paused' }"));
        assert!(code.contains("{ kind: 'Finished' }"));
        assert!(code.contains("export const GameStateSchema = borsh.rustEnum"));
        assert!(code.contains("borsh.unit('Active')"));
        assert!(code.contains("borsh.unit('Paused')"));
        assert!(code.contains("borsh.unit('Finished')"));
    }

    #[test]
    fn generates_tuple_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameEvent".to_string(),
            variants: vec![
                EnumVariantDefinition::Tuple {
                    name: "PlayerJoined".to_string(),
                    types: vec![TypeInfo::Primitive("Pubkey".to_string())],
                },
                EnumVariantDefinition::Tuple {
                    name: "ScoreUpdated".to_string(),
                    types: vec![
                        TypeInfo::Primitive("Pubkey".to_string()),
                        TypeInfo::Primitive("u64".to_string()),
                    ],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("import { PublicKey } from '@solana/web3.js'"));
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export type GameEvent ="));
        assert!(code.contains("{ kind: 'PlayerJoined'; field0: PublicKey }"));
        assert!(code.contains("{ kind: 'ScoreUpdated'; field0: PublicKey; field1: number }"));
        assert!(code.contains("borsh.tuple(["));
        assert!(code.contains("borsh.publicKey"));
        assert!(code.contains("borsh.u64"));
    }

    #[test]
    fn generates_struct_enum() {
        let type_def = TypeDefinition::Enum(EnumDefinition {
            name: "GameInstruction".to_string(),
            variants: vec![
                EnumVariantDefinition::Struct {
                    name: "Initialize".to_string(),
                    fields: vec![
                        FieldDefinition {
                            name: "authority".to_string(),
                            type_info: TypeInfo::Primitive("Pubkey".to_string()),
                            optional: false,
                        },
                        FieldDefinition {
                            name: "max_players".to_string(),
                            type_info: TypeInfo::Primitive("u32".to_string()),
                            optional: false,
                        },
                    ],
                },
                EnumVariantDefinition::Struct {
                    name: "UpdateScore".to_string(),
                    fields: vec![
                        FieldDefinition {
                            name: "player".to_string(),
                            type_info: TypeInfo::Primitive("Pubkey".to_string()),
                            optional: false,
                        },
                        FieldDefinition {
                            name: "new_score".to_string(),
                            type_info: TypeInfo::Primitive("u64".to_string()),
                            optional: false,
                        },
                    ],
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
            },
        });

        let code = generate(&type_def);
        assert!(code.contains("import { PublicKey } from '@solana/web3.js'"));
        assert!(code.contains("import * as borsh from '@coral-xyz/borsh'"));
        assert!(code.contains("export type GameInstruction ="));
        assert!(code.contains("{ kind: 'Initialize'; authority: PublicKey; max_players: number }"));
        assert!(code.contains("{ kind: 'UpdateScore'; player: PublicKey; new_score: number }"));
        assert!(code.contains("borsh.struct(["));
        assert!(code.contains("borsh.publicKey('authority')"));
        assert!(code.contains("borsh.u32('max_players')"));
        assert!(code.contains("borsh.publicKey('player')"));
        assert!(code.contains("borsh.u64('new_score')"));
    }
}
