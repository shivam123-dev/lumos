// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Integration tests for TypeScript code generator
//!
//! Tests the complete pipeline: .lumos → AST → IR → TypeScript code

use lumos_core::generators::typescript::{generate, generate_module};
use lumos_core::parser::parse_lumos_file;
use lumos_core::transform::transform_to_ir;
use std::fs;
use std::path::PathBuf;

#[test]
fn test_generate_gaming_schema() {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path.push("examples/gaming/schema.lumos");

    let content = fs::read_to_string(&path).expect("Failed to read gaming schema");

    // Parse and transform
    let ast = parse_lumos_file(&content).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    // Generate TypeScript code for all types
    let ts_code = generate_module(&ir);

    // Verify imports
    assert!(ts_code.contains("import { PublicKey } from '@solana/web3.js'"));
    assert!(ts_code.contains("import * as borsh from '@coral-xyz/borsh'"));

    // Verify interfaces
    assert!(ts_code.contains("export interface PlayerAccount"));
    assert!(ts_code.contains("export interface GameItem"));
    assert!(ts_code.contains("export interface Leaderboard"));
    assert!(ts_code.contains("export interface MatchResult"));

    // Verify fields from PlayerAccount
    assert!(ts_code.contains("wallet: PublicKey"));
    assert!(ts_code.contains("username: string"));
    assert!(ts_code.contains("level: number"));
    assert!(ts_code.contains("equipped_items: PublicKey[]"));
    assert!(ts_code.contains("achievements: number[]"));

    // Verify optional field from MatchResult
    assert!(ts_code.contains("opponent?: PublicKey | undefined"));

    // Verify Borsh schemas
    assert!(ts_code.contains("export const PlayerAccountSchema = borsh.struct"));
    assert!(ts_code.contains("borsh.publicKey('wallet')"));
    assert!(ts_code.contains("borsh.string('username')"));
    assert!(ts_code.contains("borsh.u16('level')"));
    assert!(ts_code.contains("borsh.vec(borsh.publicKey)('equipped_items')"));
    assert!(ts_code.contains("borsh.option(borsh.publicKey)('opponent')"));

    println!("Generated TypeScript code:\n{}", ts_code);
}

#[test]
fn test_generate_nft_marketplace_schema() {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path.push("examples/nft-marketplace/schema.lumos");

    let content = fs::read_to_string(&path).expect("Failed to read NFT marketplace schema");

    let ast = parse_lumos_file(&content).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let ts_code = generate_module(&ir);

    // Verify interfaces
    assert!(ts_code.contains("export interface Marketplace"));
    assert!(ts_code.contains("export interface NftListing"));
    assert!(ts_code.contains("export interface NftMetadata"));
    assert!(ts_code.contains("export interface PurchaseReceipt"));

    // Verify optional field
    assert!(ts_code.contains("expires_at?: number | undefined"));

    // Verify array field
    assert!(ts_code.contains("creators: PublicKey[]"));

    // Verify Signature type (maps to string in TypeScript)
    assert!(ts_code.contains("transaction_signature: string"));

    // Verify Borsh schemas
    assert!(ts_code.contains("borsh.vec(borsh.publicKey)('creators')"));
    assert!(ts_code.contains("borsh.option(borsh.i64)('expires_at')"));

    println!("Generated TypeScript code:\n{}", ts_code);
}

#[test]
fn test_generate_single_struct() {
    let lumos_code = r#"
        #[solana]
        #[account]
        struct SimpleAccount {
            owner: PublicKey,
            balance: u64,
        }
    "#;

    let ast = parse_lumos_file(lumos_code).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let ts_code = generate(&ir[0]);

    // Verify complete output
    assert!(ts_code.contains("// Auto-generated by LUMOS"));
    assert!(ts_code.contains("// DO NOT EDIT"));
    assert!(ts_code.contains("import { PublicKey } from '@solana/web3.js'"));
    assert!(ts_code.contains("import * as borsh from '@coral-xyz/borsh'"));
    assert!(ts_code.contains("export interface SimpleAccount"));
    assert!(ts_code.contains("owner: PublicKey"));
    assert!(ts_code.contains("balance: number"));
    assert!(ts_code.contains("export const SimpleAccountSchema = borsh.struct"));
    assert!(ts_code.contains("borsh.publicKey('owner')"));
    assert!(ts_code.contains("borsh.u64('balance')"));

    println!("Generated TypeScript code:\n{}", ts_code);
}

#[test]
fn test_generate_defi_staking_schema() {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path.push("examples/defi-staking/schema.lumos");

    let content = fs::read_to_string(&path).expect("Failed to read DeFi staking schema");

    let ast = parse_lumos_file(&content).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let ts_code = generate_module(&ir);

    // Verify interfaces exist
    assert!(ts_code.contains("export interface"));
    assert!(ts_code.contains("PublicKey"));

    // Verify Borsh schemas
    assert!(ts_code.contains("borsh.struct"));

    println!("Generated TypeScript code for DeFi Staking:\n{}", ts_code);
}

#[test]
fn test_generate_dao_governance_schema() {
    let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    path.pop();
    path.pop();
    path.push("examples/dao-governance/schema.lumos");

    let content = fs::read_to_string(&path).expect("Failed to read DAO governance schema");

    let ast = parse_lumos_file(&content).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let ts_code = generate_module(&ir);

    // Verify interfaces
    assert!(ts_code.contains("export interface"));
    assert!(ts_code.contains("PublicKey"));

    // Verify Borsh schemas
    assert!(ts_code.contains("borsh.struct"));

    println!("Generated TypeScript code for DAO Governance:\n{}", ts_code);
}

#[test]
fn test_type_mappings() {
    let lumos_code = r#"
        #[solana]
        struct AllTypes {
            tiny: u8,
            small: u16,
            medium: u32,
            large: u64,
            huge: u128,
            signed: i64,
            bigint: i128,
            float: f32,
            double: f64,
            flag: bool,
            text: String,
            key: PublicKey,
            items: [u64],
            optional: Option<String>,
        }
    "#;

    let ast = parse_lumos_file(lumos_code).expect("Failed to parse");
    let ir = transform_to_ir(ast).expect("Failed to transform");

    let ts_code = generate(&ir[0]);

    // Verify all type mappings
    assert!(ts_code.contains("tiny: number"));
    assert!(ts_code.contains("small: number"));
    assert!(ts_code.contains("medium: number"));
    assert!(ts_code.contains("large: number"));
    assert!(ts_code.contains("huge: bigint"));
    assert!(ts_code.contains("signed: number"));
    assert!(ts_code.contains("bigint: bigint"));
    assert!(ts_code.contains("float: number"));
    assert!(ts_code.contains("double: number"));
    assert!(ts_code.contains("flag: boolean"));
    assert!(ts_code.contains("text: string"));
    assert!(ts_code.contains("key: PublicKey"));
    assert!(ts_code.contains("items: number[]"));
    assert!(ts_code.contains("optional?: string | undefined"));

    // Verify Borsh mappings
    assert!(ts_code.contains("borsh.u8('tiny')"));
    assert!(ts_code.contains("borsh.u16('small')"));
    assert!(ts_code.contains("borsh.u32('medium')"));
    assert!(ts_code.contains("borsh.u64('large')"));
    assert!(ts_code.contains("borsh.u128('huge')"));
    assert!(ts_code.contains("borsh.i64('signed')"));
    assert!(ts_code.contains("borsh.i128('bigint')"));
    assert!(ts_code.contains("borsh.f32('float')"));
    assert!(ts_code.contains("borsh.f64('double')"));
    assert!(ts_code.contains("borsh.bool('flag')"));
    assert!(ts_code.contains("borsh.string('text')"));
    assert!(ts_code.contains("borsh.publicKey('key')"));
    assert!(ts_code.contains("borsh.vec(borsh.u64)('items')"));
    assert!(ts_code.contains("borsh.option(borsh.string)('optional')"));

    println!("Generated TypeScript code with all types:\n{}", ts_code);
}
