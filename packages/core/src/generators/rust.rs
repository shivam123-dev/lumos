// Licensed under either of Apache License, Version 2.0 or MIT license at your option.
// Copyright 2025 RECTOR-LABS

//! Rust code generator
//!
//! Generates production-ready Rust code from IR for use in Solana programs.

use crate::ir::{TypeDefinition, TypeInfo};
use std::collections::HashSet;

/// Generate Rust code from a type definition
pub fn generate(type_def: &TypeDefinition) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Determine if this struct uses Anchor (#[account])
    let use_anchor = type_def.metadata.solana
        && type_def.metadata.attributes.contains(&"account".to_string());

    // Collect required imports
    let imports = collect_imports(type_def);
    if !imports.is_empty() {
        for import in imports {
            output.push_str(&format!("use {};\n", import));
        }
        output.push_str("\n");
    }

    // Generate derives using context-aware function
    let derives = generate_derives_with_context(type_def, use_anchor);
    if !derives.is_empty() {
        output.push_str(&format!("#[derive({})]\n", derives.join(", ")));
    }

    // Add Solana-specific attributes
    if use_anchor {
        output.push_str("#[account]\n");
    }

    // Generate struct definition
    output.push_str(&format!("pub struct {} {{\n", type_def.name));

    // Generate fields
    for field in &type_def.fields {
        let rust_type = map_type_to_rust(&field.type_info);
        output.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
    }

    output.push_str("}\n");

    output
}

/// Generate Rust code for multiple type definitions
pub fn generate_module(type_defs: &[TypeDefinition]) -> String {
    let mut output = String::new();

    // Add file header
    output.push_str("// Auto-generated by LUMOS\n");
    output.push_str("// DO NOT EDIT - Changes will be overwritten\n\n");

    // Check if ANY struct uses #[account]
    let has_account_attr = type_defs
        .iter()
        .any(|t| t.metadata.solana && t.metadata.attributes.contains(&"account".to_string()));

    // Collect all imports needed
    let mut all_imports = HashSet::new();

    // Determine which import style to use
    if has_account_attr {
        // If any struct uses #[account], use Anchor imports for everything
        all_imports.insert("anchor_lang::prelude::*".to_string());
    } else {
        // Otherwise collect individual imports
        for type_def in type_defs {
            let imports = collect_imports(type_def);
            all_imports.extend(imports);
        }
    }

    // Check for Solana-specific types
    let mut needs_pubkey = false;
    for type_def in type_defs {
        for field in &type_def.fields {
            check_needs_solana_types(&field.type_info, &mut needs_pubkey);
        }
    }

    if needs_pubkey {
        all_imports.insert("solana_program::pubkey::Pubkey".to_string());
    }

    // Write imports
    if !all_imports.is_empty() {
        let mut sorted_imports: Vec<_> = all_imports.into_iter().collect();
        sorted_imports.sort();
        for import in sorted_imports {
            output.push_str(&format!("use {};\n", import));
        }
        output.push_str("\n");
    }

    // Generate each type definition
    for (i, type_def) in type_defs.iter().enumerate() {
        if i > 0 {
            output.push_str("\n");
        }
        output.push_str(&generate_struct_with_context(type_def, has_account_attr));
    }

    output
}

/// Check if type needs Solana-specific imports
fn check_needs_solana_types(type_info: &TypeInfo, needs_pubkey: &mut bool) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            if type_name == "Pubkey" || type_name == "PublicKey" {
                *needs_pubkey = true;
            }
        }
        TypeInfo::Array(inner) => {
            check_needs_solana_types(inner, needs_pubkey);
        }
        TypeInfo::Option(inner) => {
            check_needs_solana_types(inner, needs_pubkey);
        }
        TypeInfo::UserDefined(_) => {}
    }
}

/// Generate just the struct definition (without imports/header)
fn generate_struct_only(type_def: &TypeDefinition) -> String {
    generate_struct_with_context(type_def, false)
}

/// Generate struct with context (e.g., whether module uses Anchor)
fn generate_struct_with_context(type_def: &TypeDefinition, use_anchor: bool) -> String {
    let mut output = String::new();

    // Generate derives (only if there are any)
    let derives = generate_derives_with_context(type_def, use_anchor);
    if !derives.is_empty() {
        output.push_str(&format!("#[derive({})]\n", derives.join(", ")));
    }

    // Add Solana-specific attributes
    if type_def.metadata.solana && type_def.metadata.attributes.contains(&"account".to_string()) {
        output.push_str("#[account]\n");
    }

    // Generate struct definition
    output.push_str(&format!("pub struct {} {{\n", type_def.name));

    // Generate fields
    for field in &type_def.fields {
        let rust_type = map_type_to_rust(&field.type_info);
        output.push_str(&format!("    pub {}: {},\n", field.name, rust_type));
    }

    output.push_str("}\n");

    output
}

/// Generate derives with context about whether we're using Anchor
fn generate_derives_with_context(type_def: &TypeDefinition, use_anchor: bool) -> Vec<String> {
    let mut derives = Vec::new();

    // If using #[account], no derives needed (Anchor provides them)
    if type_def.metadata.solana && type_def.metadata.attributes.contains(&"account".to_string()) {
        return derives;
    }

    // If it's a Solana type but module uses Anchor, use Anchor derives
    if type_def.metadata.solana && use_anchor {
        derives.push("AnchorSerialize".to_string());
        derives.push("AnchorDeserialize".to_string());
        derives.push("Debug".to_string());
        derives.push("Clone".to_string());
        return derives;
    }

    // Otherwise use Borsh derives
    if type_def.metadata.solana {
        derives.push("BorshSerialize".to_string());
        derives.push("BorshDeserialize".to_string());
    }

    derives.push("Debug".to_string());
    derives.push("Clone".to_string());

    derives
}

/// Collect required imports based on type definition
fn collect_imports(type_def: &TypeDefinition) -> HashSet<String> {
    let mut imports = HashSet::new();

    // Check if we need Borsh or Anchor imports
    if type_def.metadata.solana {
        // If using #[account], use Anchor imports (includes Borsh)
        if type_def.metadata.attributes.contains(&"account".to_string()) {
            imports.insert("anchor_lang::prelude::*".to_string());
        } else {
            // Otherwise use Borsh directly
            imports.insert("borsh::{BorshSerialize, BorshDeserialize}".to_string());
        }
    }

    // Check field types for Solana-specific imports
    for field in &type_def.fields {
        collect_imports_from_type(&field.type_info, &mut imports);
    }

    imports
}

/// Recursively collect imports from a type
fn collect_imports_from_type(type_info: &TypeInfo, imports: &mut HashSet<String>) {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            // Handle both Pubkey and PublicKey (they map to same Rust type)
            if type_name == "Pubkey" || type_name == "PublicKey" {
                imports.insert("solana_program::pubkey::Pubkey".to_string());
            }
            // Note: Signature is mapped to String in Rust (no special import needed)
        }
        TypeInfo::Array(inner) => {
            collect_imports_from_type(inner, imports);
        }
        TypeInfo::Option(inner) => {
            collect_imports_from_type(inner, imports);
        }
        TypeInfo::UserDefined(_) => {
            // User-defined types are assumed to be in the same module
        }
    }
}

/// Generate derive macros based on metadata
fn generate_derives(type_def: &TypeDefinition) -> Vec<String> {
    let mut derives = Vec::new();

    // If using Anchor #[account], don't add any derives (Anchor provides them)
    if type_def.metadata.solana && type_def.metadata.attributes.contains(&"account".to_string()) {
        return derives; // Empty - Anchor #[account] provides all derives
    }

    // Add Borsh derives for Solana types
    if type_def.metadata.solana {
        derives.push("BorshSerialize".to_string());
        derives.push("BorshDeserialize".to_string());
    }

    // Always add Debug and Clone (when not using #[account])
    derives.push("Debug".to_string());
    derives.push("Clone".to_string());

    derives
}

/// Map IR type to Rust type
fn map_type_to_rust(type_info: &TypeInfo) -> String {
    match type_info {
        TypeInfo::Primitive(type_name) => {
            // Handle type mapping
            match type_name.as_str() {
                // Already Rust types
                "u8" | "u16" | "u32" | "u64" | "u128" => type_name.clone(),
                "i8" | "i16" | "i32" | "i64" | "i128" => type_name.clone(),
                "f32" | "f64" => type_name.clone(),
                "bool" => "bool".to_string(),
                "String" => "String".to_string(),

                // Solana types
                "Pubkey" => "Pubkey".to_string(),
                "PublicKey" => "Pubkey".to_string(), // Map PublicKey to Pubkey
                "Signature" => "String".to_string(), // Map Signature to String (base58)
                "Keypair" => "Keypair".to_string(),

                // Unknown type - pass through
                _ => type_name.clone(),
            }
        }
        TypeInfo::Array(inner) => {
            let inner_type = map_type_to_rust(inner);
            format!("Vec<{}>", inner_type)
        }
        TypeInfo::Option(inner) => {
            let inner_type = map_type_to_rust(inner);
            format!("Option<{}>", inner_type)
        }
        TypeInfo::UserDefined(type_name) => type_name.clone(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{FieldDefinition, Metadata, TypeDefinition, TypeInfo};

    #[test]
    fn generates_simple_struct() {
        let type_def = TypeDefinition {
            name: "User".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "id".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "name".to_string(),
                    type_info: TypeInfo::Primitive("String".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub id: u64"));
        assert!(code.contains("pub name: String"));
        assert!(code.contains("Debug, Clone"));
    }

    #[test]
    fn generates_solana_account() {
        let type_def = TypeDefinition {
            name: "UserAccount".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "wallet".to_string(),
                    type_info: TypeInfo::Primitive("Pubkey".to_string()),
                    optional: false,
                },
                FieldDefinition {
                    name: "balance".to_string(),
                    type_info: TypeInfo::Primitive("u64".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec!["account".to_string()],
            },
        };

        let code = generate(&type_def);
        assert!(code.contains("use anchor_lang::prelude::*"));
        assert!(code.contains("use solana_program::pubkey::Pubkey"));
        assert!(code.contains("#[account]"));
        // Note: #[account] structs don't have derives (Anchor provides them)
        assert!(!code.contains("#[derive"));
        assert!(code.contains("pub wallet: Pubkey"));
    }

    #[test]
    fn generates_optional_fields() {
        let type_def = TypeDefinition {
            name: "Profile".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "email".to_string(),
                    type_info: TypeInfo::Option(Box::new(TypeInfo::Primitive(
                        "String".to_string(),
                    ))),
                    optional: true,
                },
            ],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("pub email: Option<String>"));
    }

    #[test]
    fn generates_array_fields() {
        let type_def = TypeDefinition {
            name: "Team".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "members".to_string(),
                    type_info: TypeInfo::Array(Box::new(TypeInfo::Primitive("u64".to_string()))),
                    optional: false,
                },
            ],
            metadata: Metadata::default(),
        };

        let code = generate(&type_def);
        assert!(code.contains("pub members: Vec<u64>"));
    }

    #[test]
    fn generates_module_with_multiple_types() {
        let type_defs = vec![
            TypeDefinition {
                name: "User".to_string(),
                fields: vec![],
                metadata: Metadata::default(),
            },
            TypeDefinition {
                name: "Post".to_string(),
                fields: vec![],
                metadata: Metadata::default(),
            },
        ];

        let code = generate_module(&type_defs);
        assert!(code.contains("pub struct User"));
        assert!(code.contains("pub struct Post"));
    }

    #[test]
    fn maps_publickey_to_pubkey() {
        let type_def = TypeDefinition {
            name: "Account".to_string(),
            fields: vec![
                FieldDefinition {
                    name: "key".to_string(),
                    type_info: TypeInfo::Primitive("PublicKey".to_string()),
                    optional: false,
                },
            ],
            metadata: Metadata {
                solana: true,
                attributes: vec![],
            },
        };

        let code = generate(&type_def);
        assert!(code.contains("pub key: Pubkey"));
    }
}
